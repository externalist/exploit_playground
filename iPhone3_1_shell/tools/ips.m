@import Foundation;
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

#include <stdio.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/attr.h>
#include <mach/mach.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/mount.h>
#include <spawn.h>
#include <sys/sysctl.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

#include <stdint.h>

#include <mach/mach.h>
#include <CoreFoundation/CoreFoundation.h>
#include <mach/task.h>

int runningProcesses()
{
    int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};
    size_t miblen = 4;

    size_t size;
    int st = sysctl(mib, miblen, NULL, &size, NULL, 0);

    struct kinfo_proc * process = NULL;
    struct kinfo_proc * newprocess = NULL;

    do {

        size += size / 10;
        newprocess = realloc(process, size);

        if (!newprocess) {

            if (process){
                free(process);
            }

            return 0;
        }

        process = newprocess;
        st = sysctl(mib, miblen, process, &size, NULL, 0);

    } while (st == -1 && errno == ENOMEM);

    if (st == 0) {

	printf("%5s\t%s\n", "pid", "name");
        if (size % sizeof(struct kinfo_proc) == 0){
            int nprocess = size / sizeof(struct kinfo_proc);

            if (nprocess) {

                for (int i = nprocess - 1; i >= 0; i--) {
			printf("%5d\t%s\n", process[i].kp_proc.p_pid, process[i].kp_proc.p_comm);
                }

                free(process);
            }
        }
    }

    return 0;
}

int main(int argc, char **argv)
{
	runningProcesses();
}

